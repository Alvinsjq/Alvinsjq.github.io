---
layout: post
title:  "MIT6.828 Lab1 Booting a PC Part 3 exercise 9-12"
tags: [MIT6.828, Operating System, 操作系统, 学习历程 , kernel]
comments: true
description: "深入JOS的内核细节"
keywords: "OS,kernel"
date:   2017-02-15 14:40:22 +0800
---


## 实验一大纲
- 环境配置
- 第一部分：PC Bootstrap
    - x86汇编
    - 模拟x86
    -  PC的物理地址空间
    -  ROM BIOS
- 第二部分：The Boot Loader
    - 加载内核
- 第三部分：The kernel


## 第三部分 The kernel

### 栈 the stack

在本实验的最后一部分，我们将探讨一下C语言是如何在x86机器上使用堆栈的。并且我们还会重新编写一个新的kernel monitor子程序。这个程序可以记录堆栈的变化轨迹：轨迹是由一系列被保存到堆栈的IP寄存器的值组成的，之所以会产生这一系列被保存的IP寄存器的值，是因为我们执行了一个程序，程序中包括一系列嵌套的call指令。

>练习9:内核在哪里初始化它的栈，并且栈到底在内存的什么地方？内核又是怎样给它的栈保留空间的？栈指针初始是指向保留区域的哪一端呢？

1. 内核在哪里初始化

经过boot.S和main.c函数，知道在bootmain函数中进入entry，也就是entry.S:

```c 
relocated:

    # Clear the frame pointer register (EBP)
    # so that once we get into debugging C code,
    # stack backtraces will be terminated properly.
    movl    $0x0,%ebp           # nuke frame pointer

    # Set the stack pointer
    movl    $(bootstacktop),%esp         
```

这两个指令做的就是对ebp和esp的修改，因此内核就在这里初始化了栈。


2. 栈到底在内存的什么地方？



x86栈指针指向栈中目前被使用的部分的最低地址。在该地址之下的地址都是没被利用的栈空间。向栈中Push一个值包括降低栈指针，并将值写入栈指针指向的空间。从栈中POP一个值包括读取栈指针指向的空间的值，然后增加栈指针。在32-bit模式，栈只能保证32bit的值，并且栈指针总是被4整除。各种x86指令，例如call，用栈指针寄存器是hard-wired。

ebp（基指针）寄存器，相反，由于软件惯例主要与栈相关。当进入一个C函数，函数的前件代码通常通过将基指针Push到栈中来保存先前函数的基指针。然后在该函数期间，将目前的esp的值拷贝到ebp。若所有的程序中的函数都遵循这个习惯，那么在该程序执行的过程中，用一下保存的ebp指针链追踪栈，并确定到底哪个函数调用的嵌套造成该程序的特殊的指针。这个能力尤为重要，一个栈道反追踪会让你找到冒犯的函数。

>练习10:为了能够更好的了解在x86上的C程序调用过程的细节，我们首先找到在obj/kern/kern.asm中test_backtrace子程序的地址，设置断点，并且探讨一下在内核启动后，这个程序被调用时发生了什么。对于这个循环嵌套调用的程序test_backtrace，它一共压入了多少信息到堆栈之中。并且它们都代表什么含义？



backtrace函数应该展示以下框架的信息：

```
Stack backtrace:
  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031
  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061
  ...
```


每一行包括ebp、eip和args。
ebp：被函数利用的指向栈的基指针；
eip：函数返回的指令指针；
args：前5个arguments，在函数被调用之前被push到栈。


第一行表示的就是正在执行的函数，也就是mon_backtrace本身，第二行反映的是调用mon_backtrace的函数，第三行表示的是调用上一行函数的函数，以此类推。你需要打印出所有的栈信息。通过学习kern/entry.S你会发现又一个容易的方法来分辨何时停止。


>练习11:实现上面的backtrace函数。用和考试一样的格式，不然会与成绩脚本冲突。运行```make grade```看看是否和成绩脚本一致，如果不的话要对其进行修改。


此时，你的backtrace函数应该在栈上给你函数调用的地址，这个栈导致了mon_backtrace()的执行。然而你往往会想知道对应的那些地址的函数名。例如你想知道哪个函数会包含可以使内核死机的bug。

为了帮助你实现这个功能，我们提供函数debuginfo_eip()，查看eip的符号表并返回那些地址的调试信息。这个函数在kern/kdebug.c定义了。



> 练习12:修改你的栈backtrace函数，对每一eip，展示对应的函数名、源文件名、行数。 










