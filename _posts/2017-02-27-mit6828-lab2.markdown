---
layout: post
title:  "MIT6.828 Lab 2 : Memory Management"
tags: [MIT6.828,OS,Memory Management]
comments: true
description: "关于操作系统的内存管理..."
keywords: ""
date:   2017-02-27 14:40:22 +0800
---


## MIT6.828 Lab 2 : Memory Management

- Part 1: Physical Page Management
- Part 2: Virtual Memory
- Part 3: Kernel Address Space

#### 导言

内存管理的两部分：内核物理地址的分配器、虚拟内存。

内核物理地址分配可以使内核能过分配内存并在之后释放内存，也就使Pages，占4096bytes单元。

虚拟内存将内核以及用户软件利用的虚拟地址映射到物理内存地址。当指令在利用内存时，设置MMU，然后得到页表。

任务：

- 维护记录物理pages空闲和已分配的数据结构，写出分配和释放内存的页的过程。
- 根据提供的说明建立MMU的页表来改造JOS。


#### 实验准备

实验2新加了以下几个源文件：

1. inc/memlayout.h  虚拟地址空间的布局（通过修改2实现）
2. kern/pmap.c 阅读这个设备硬件，以便弄清有多少物理地址，不过这部分已经写好了，因为不需要知道CMOS硬件工作的细节
3. kern/pmap.h 定义PageInfo结构，它可以追踪哪个物理内存的页是空闲的
4. kern/kclock.h  4和5操作着PC的电子时钟和CMOS RAM硬件
5. kern/kclock.c

1和3需要都知道它们中的定义，也许还要看inc/mmu.h

#### 第一部分：物理页管理

操作系统必须追踪哪部分物理RAM是空闲的、正在使用的。JOS用page granularity来管理物理内存以便它可以使用MMU（硬件内存管理单元）去映射和保护分配的内存的每一块。

这部分要写的是物理页的分配器。它可以在struct PageInfo 对象（每一个对象代表一个物理页）的一个链接列表得到那些页是空闲的，在实现虚拟地址之前先要完成这个，因为页表管理需要分配储存在页表中的物理内存。

>练习1:In the file kern/pmap.c, you must implement code for the following functions (probably in the order given)：

```
boot_alloc()
mem_init() (only up to the call to check_page_free_list(1))
page_init()
page_alloc()
page_free()
```

>check_page_free_list() and check_page_alloc() test your physical page allocator. You should boot JOS and see whether check_page_alloc() reports success. Fix your code so that it passes. You may find it helpful to add your own assert()s to verify that your assumptions are correct.




