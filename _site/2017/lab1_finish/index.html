<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta name="apple-mobile-web-app-capable" content="yes"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> MIT6.828 Lab1 Booting a PC Part 3 exercise 9-12 | Alvin Is </title> <!-- Icons --> <link rel="apple-touch-icon" type=" image/png" sizes="144x144" href="assets/images/webicon.png"> <link rel="icon" type=" image/png" href="/assets/images/webicon_32.png"> <link rel="shortcut icon" type=" image/png" href="/assets/images/webicon_32.png"> <meta name="description" content=" 深入JOS的内核细节 "> <meta name="keywords" content="OS,kernel"> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <!-- Social: Facebook / Open Graph --> <meta property="og:type" content="article"> <meta property="article:author" content="Alvinsjq"> <meta property="article:section" content=""> <meta property="article:tag" content="OS,kernel"> <meta property="article:published_time" content="2017-02-15 14:40:22 +0800"> <meta property="og:url" content="http://alvinsjq.github.io/2017/lab1_finish/"> <meta property="og:title" content=" MIT6.828 Lab1 Booting a PC Part 3 exercise 9-12 | Alvin Is "> <meta property="og:image" content="http://alvinsjq.github.io"> <meta property="og:description" content=" 深入JOS的内核细节 "> <meta property="og:site_name" content="Alvinsjq"> <meta property="og:locale" content="en_US"> <!-- Social: Twitter --> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:site" content="@Alvin_sjq"> <meta name="twitter:title" content=" MIT6.828 Lab1 Booting a PC Part 3 exercise 9-12 | Alvin Is "> <meta name="twitter:description" content=" 深入JOS的内核细节 "> <meta name="twitter:image:src" content="http://alvinsjq.github.io"> <!-- Social: Google+ / Schema.org --> <meta itemprop="name" content=" MIT6.828 Lab1 Booting a PC Part 3 exercise 9-12 | Alvin Is "> <meta itemprop="description" content=" 深入JOS的内核细节 "> <meta itemprop="image" content="http://alvinsjq.github.io"> <!-- rel prev and next --> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/font-awesome.min.css"> <!-- Canonical link tag --> <link rel="canonical" href="http://alvinsjq.github.io/2017/lab1_finish/"> <link rel="alternate" type="application/rss+xml" title="Alvin Is" href="http://alvinsjq.github.io/feed.xml"> <script type="text/javascript"> var disqus_shortname = 'alvin-is'; var _gaq = _gaq || []; _gaq.push(['_setAccount', '']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); </script> <script src="https://code.jquery.com/jquery-3.2.0.min.js"></script> <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script> <script>AV.initialize("OfIL1RlM4M4n30dWx3wXlEIz-gzGzoHsz", "LlDtB3Xu9be1655lnGQdPedO");</script> <script> function showHitCount(Counter) { var query = new AV.Query(Counter); var entries = []; var $visitors = $(".leancloud_visitors"); $visitors.each(function () { entries.push( $(this).attr("id").trim() ); }); query.containedIn('url', entries); query.find() .done(function (results) { var COUNT_CONTAINER_REF = '.leancloud-visitors-count'; if (results.length === 0) { $visitors.find(COUNT_CONTAINER_REF).text(0); return; } for (var i = 0; i < results.length; i++) { var item = results[i]; var url = item.get('url'); var hits = item.get('hits'); var element = document.getElementById(url); $(element).find(COUNT_CONTAINER_REF).text(hits); } for(var i = 0; i < entries.length; i++) { var url = entries[i]; var element = document.getElementById(url); var countSpan = $(element).find(COUNT_CONTAINER_REF); if( countSpan.text() == '') { countSpan.text(0); } } }) .fail(function (object, error) { console.log("Error: " + error.code + " " + error.message); }); } function addCount(Counter) { var $visitors = $(".leancloud_visitors"); var url = $visitors.attr('id').trim(); var title = $visitors.attr('data-flag-title').trim(); var query = new AV.Query(Counter); query.equalTo("url", url); query.find({ success: function(results) { if (results.length > 0) { var counter = results[0]; counter.fetchWhenSave(true); counter.increment("hits"); counter.save(null, { success: function(counter) { var $element = $(document.getElementById(url)); $element.find('.leancloud-visitors-count').text(counter.get('hits')); }, error: function(counter, error) { console.log('Failed to save Visitor num, with error message: ' + error.message); } }); } else { var newcounter = new Counter(); var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); newcounter.setACL(acl); newcounter.set("title", title); newcounter.set("url", url); newcounter.set("hits", 1); newcounter.save(null, { success: function(newcounter) { var $element = $(document.getElementById(url)); $element.find('.leancloud-visitors-count').text(newcounter.get('hits')); }, error: function(newcounter, error) { console.log('Failed to create'); } }); } }, error: function(error) { console.log('Error:' + error.code + " " + error.message); } }); } $(function() { var Counter = AV.Object.extend("Counter"); if ($('.leancloud_visitors').length == 1) { addCount(Counter); } else if ($('.post-link').length > 1){ showHitCount(Counter); } }); </script> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?011d93aa32b263cf21d7c9a15165b8a0"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> </head> <body> <main class="wrapper"> <header class="site-header"> <nav class="nav"> <div class="container"> <h1 class="logo"><a href="/">Alvin Is<span></span></a></h1> <ul class="navbar"> <li><a href="/about">About</a></li> <li><a href="/talks">Topics</a></li> <li><a href="/archives">Archives</a></li> <li><a href="/feed.xml" target="_blank"></a></li> </ul> </div> </nav> </header> <article class="post container" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"> <p class="post-meta"><time datetime="2017-02-15T14:40:22+08:00" itemprop="datePublished">Feb 15, 2017</time> <span id="/2017/lab1_finish/" class="leancloud_visitors" data-flag-title="MIT6.828 Lab1 Booting a PC Part 3 exercise 9-12"> <span class="post-meta-divider">|</span> <span class="post-meta-item-text"> 浏览次数: </span> <span class="leancloud-visitors-count"></span> </span> </p> <h1 class="post-title" itemprop="name headline">MIT6.828 Lab1 Booting a PC Part 3 exercise 9-12</h1> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } }); </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } }); </script> <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> </header> <div class="post-content" itemprop="articleBody"> <h2 id="section">实验一大纲</h2> <ul> <li>环境配置</li> <li>第一部分：PC Bootstrap <ul> <li>x86汇编</li> <li>模拟x86</li> <li>PC的物理地址空间</li> <li>ROM BIOS</li> </ul> </li> <li>第二部分：The Boot Loader <ul> <li>加载内核</li> </ul> </li> <li>第三部分：The kernel</li> </ul> <h2 id="the-kernel">第三部分 The kernel</h2> <h3 id="the-stack">栈 the stack</h3> <p>在本实验的最后一部分，我们将探讨一下C语言是如何在x86机器上使用堆栈的。并且我们还会重新编写一个新的kernel monitor子程序。这个程序可以记录堆栈的变化轨迹：轨迹是由一系列被保存到堆栈的IP寄存器的值组成的，之所以会产生这一系列被保存的IP寄存器的值，是因为我们执行了一个程序，程序中包括一系列嵌套的call指令。</p> <blockquote> <p>练习9:内核在哪里初始化它的栈，并且栈到底在内存的什么地方？内核又是怎样给它的栈保留空间的？栈指针初始是指向保留区域的哪一端呢？</p> </blockquote> <ol> <li>内核在哪里初始化</li> </ol> <p>经过boot.S和main.c函数，知道在bootmain函数中进入entry，也就是entry.S:</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="nl">relocated:</span>

    <span class="cp"># Clear the frame pointer register (EBP)
</span>    <span class="cp"># so that once we get into debugging C code,
</span>    <span class="cp"># stack backtraces will be terminated properly.
</span>    <span class="n">movl</span>    <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="n">ebp</span>           <span class="err">#</span> <span class="n">nuke</span> <span class="n">frame</span> <span class="n">pointer</span>

    <span class="cp"># Set the stack pointer
</span>    <span class="n">movl</span>    <span class="err">$</span><span class="p">(</span><span class="n">bootstacktop</span><span class="p">),</span><span class="o">%</span><span class="n">esp</span>         
</code></pre></div> <p>kernel.asm中：<br /> ```c<br /> # Clear the frame pointer register (EBP)<br /> # so that once we get into debugging C code,<br /> # stack backtraces will be terminated properly.<br /> movl $0x0,%ebp # nuke frame pointer<br /> f010002f: bd 00 00 00 00 mov $0x0,%ebp</p> <p># Set the stack pointer<br /> movl $(bootstacktop),%esp<br /> f0100034: bc 00 00 11 f0 mov $0xf0110000,%esp<br /> ```</p> <p>这两个指令做的就是对ebp和esp的修改，因此内核就在0xf0110000处开始初始化了栈。</p> <ol> <li>栈到底在内存的什么地方？</li> </ol> <p>在GDB中设置断点，输入命令c和si得到：</p> <div class="highlighter-rouge"><pre class="highlight"><code>The target architecture is assumed to be i8086
[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b
0x0000fff0 in ?? ()
+ symbol-file obj/kern/kernel
(gdb) b * 0x7d65
Breakpoint 1 at 0x7d65
(gdb) c
Continuing.
The target architecture is assumed to be i386
=&gt; 0x7d65:  call   *0x10018

Breakpoint 1, 0x00007d65 in ?? ()
(gdb) si
=&gt; 0x10000c:  movw   $0x1234,0x472
</code></pre></div> <p>此时指令地址在0x10000c处，这也是系统内核的第一条指令；</p> <p>下面一段代码是将虚拟地址转换为真实地址：</p> <div class="highlighter-rouge"><pre class="highlight"><code>  <span class="n">movl</span>  <span class="err">$</span><span class="p">(</span><span class="n">RELOC</span><span class="p">(</span><span class="n">entry_pgdir</span><span class="p">)),</span> <span class="o">%</span><span class="n">eax</span>
  <span class="n">movl</span>  <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">cr3</span>
  <span class="cp"># Turn on paging.
</span>  <span class="n">movl</span>  <span class="o">%</span><span class="n">cr0</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
  <span class="n">orl</span> <span class="err">$</span><span class="p">(</span><span class="n">CR0_PE</span><span class="o">|</span><span class="n">CR0_PG</span><span class="o">|</span><span class="n">CR0_WP</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
  <span class="n">movl</span>  <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">cr0</span>
</code></pre></div> <p>这段代码的功能是将[0xf0000000-0xf0400000]这4MB大小的虚拟地址空间映射为[0x00000000-0x00400000]的物理地址空间。会发现这两个空间的间隔是一样的。</p> <p>首先entry_pgdir是页表，而RELOC可以计算该页表的起始物理地址，第一行代码将值赋值给%eax，接着又将该值赋值给%cr3寄存器，因此该寄存器存放着页表的起始地址。接着就是打开页表。</p> <p>下面再看：<br /> <code class="highlighter-rouge">c =&gt; 0x100028: mov $0xf010002f,%eax 0x00100028 in ?? () (gdb) =&gt; 0x10002d: jmp *%eax 0x0010002d in ?? () </code></p> <p>不难发现relocated的地址是0xf010002f，那么分页系统就会将该地址转化为真实的物理地址。</p> <p>最重要的两句指令就是：</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="o">=&gt;</span> <span class="mh">0xf010002f</span> <span class="o">&lt;</span><span class="n">relocated</span><span class="o">&gt;:</span>  <span class="n">mov</span>    <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="n">ebp</span>
<span class="n">relocated</span> <span class="p">()</span> <span class="n">at</span> <span class="n">kern</span><span class="o">/</span><span class="n">entry</span><span class="p">.</span><span class="n">S</span><span class="o">:</span><span class="mi">74</span>
<span class="mi">74</span>    <span class="n">movl</span>  <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="n">ebp</span>     <span class="err">#</span> <span class="n">nuke</span> <span class="n">frame</span> <span class="n">pointer</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> 
<span class="o">=&gt;</span> <span class="mh">0xf0100034</span> <span class="o">&lt;</span><span class="n">relocated</span><span class="o">+</span><span class="mi">5</span><span class="o">&gt;:</span>  <span class="n">mov</span>    <span class="err">$</span><span class="mh">0xf0110000</span><span class="p">,</span><span class="o">%</span><span class="n">esp</span>
<span class="n">relocated</span> <span class="p">()</span> <span class="n">at</span> <span class="n">kern</span><span class="o">/</span><span class="n">entry</span><span class="p">.</span><span class="n">S</span><span class="o">:</span><span class="mi">77</span>
<span class="mi">77</span>    <span class="n">movl</span>  <span class="err">$</span><span class="p">(</span><span class="n">bootstacktop</span><span class="p">),</span><span class="o">%</span><span class="n">esp</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> 
<span class="o">=&gt;</span> <span class="mh">0xf0100039</span> <span class="o">&lt;</span><span class="n">relocated</span><span class="o">+</span><span class="mi">10</span><span class="o">&gt;:</span> <span class="n">call</span>   <span class="mh">0xf010009d</span> <span class="o">&lt;</span><span class="n">i386_init</span><span class="o">&gt;</span>
<span class="mi">80</span>    <span class="n">call</span>  <span class="n">i386_init</span>
</code></pre></div> <p>对应的enrty.S的代码是：</p> <div class="highlighter-rouge"><pre class="highlight"><code>  <span class="cp"># Clear the frame pointer register (EBP)
</span>  <span class="cp"># so that once we get into debugging C code,
</span>  <span class="cp"># stack backtraces will be terminated properly.
</span>  <span class="n">movl</span>  <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="n">ebp</span>     <span class="err">#</span> <span class="n">nuke</span> <span class="n">frame</span> <span class="n">pointer</span>

  <span class="cp"># Set the stack pointer
</span>  <span class="n">movl</span>  <span class="err">$</span><span class="p">(</span><span class="n">bootstacktop</span><span class="p">),</span><span class="o">%</span><span class="n">esp</span>

  <span class="cp"># now to C code
</span>  <span class="n">call</span>  <span class="n">i386_init</span>
</code></pre></div> <p>它们设置了寄存器ebp和esp的值，ebp变为0，而esp修改为bootstacktop的值，该值为0xf0110000，这就是栈顶指针。</p> <p>注意这样一段代码：</p> <div class="highlighter-rouge"><pre class="highlight"><code>.data
###################################################################
# boot stack
###################################################################
  .p2align  PGSHIFT   # force page alignment
  .globl    bootstack
bootstack:
  .space    KSTKSIZE
  .globl    bootstacktop   
bootstacktop:
</code></pre></div> <p>其中KSTKSIZE有预定义<br /> <code class="highlighter-rouge">c #define KSTKSIZE (8*PGSIZE) </code><br /> 计算一下大概就是32KB，而栈顶地址为0xf0110000。</p> <p>当然这里的<br /> <code class="highlighter-rouge">c #define KSTKSIZE (8*PGSIZE) </code><br /> 其实也就是内核为栈提供的空间。</p> <ol> <li>栈指针指向哪一端？<br /> 最高地址那端。</li> </ol> <p>x86栈指针指向栈中目前被使用的部分的最低地址。在该地址之下的地址都是没被利用的栈空间。向栈中Push一个值包括降低栈指针，并将值写入栈指针指向的空间。从栈中POP一个值包括读取栈指针指向的空间的值，然后增加栈指针。在32-bit模式，栈只能保证32bit的值，并且栈指针总是被4整除。各种x86指令，例如call，用栈指针寄存器是hard-wired。</p> <p>ebp（基指针）寄存器，相反，由于软件惯例主要与栈相关。当进入一个C函数，函数的前件代码通常通过将基指针Push到栈中来保存先前函数的基指针。然后在该函数期间，将目前的esp的值拷贝到ebp。若所有的程序中的函数都遵循这个习惯，那么在该程序执行的过程中，用一下保存的ebp指针链追踪栈，并确定到底哪个函数调用的嵌套造成该程序的特殊的指针。这个能力尤为重要，一个栈道反追踪会让你找到冒犯的函数。</p> <blockquote> <p>练习10:为了能够更好的了解在x86上的C程序调用过程的细节，我们首先找到在obj/kern/kern.asm中test_backtrace子程序的地址，设置断点，并且探讨一下在内核启动后，这个程序被调用时发生了什么。对于这个循环嵌套调用的程序test_backtrace，它一共压入了多少信息到堆栈之中。并且它们都代表什么含义？</p> </blockquote> <p>首先函数test_backtrace在kern：<br /> <code class="highlighter-rouge">c // Test the stack backtrace function (lab 1 only) void test_backtrace(int x) { f0100040: 55 push %ebp =========&gt;开始地址 f0100041: 89 e5 mov %esp,%ebp f0100043: 53 push %ebx f0100044: 83 ec 14 sub $0x14,%esp (5)===&gt;esp : 0xf010ffc0 ebp：0xf010ffd8 f0100047: 8b 5d 08 mov 0x8(%ebp),%ebx cprintf("entering test_backtrace %d\n", x); f010004a: 89 5c 24 04 mov %ebx,0x4(%esp) f010004e: c7 04 24 80 19 10 f0 movl $0xf0101980,(%esp) f0100055: e8 d4 08 00 00 call f010092e &lt;cprintf&gt; if (x &gt; 0) f010005a: 85 db test %ebx,%ebx f010005c: 7e 0d jle f010006b &lt;test_backtrace+0x2b&gt; test_backtrace(x-1); f010005e: 8d 43 ff lea -0x1(%ebx),%eax f0100061: 89 04 24 mov %eax,(%esp) f0100064: e8 d7 ff ff ff call f0100040 &lt;test_backtrace&gt; f0100069: eb 1c jmp f0100087 &lt;test_backtrace+0x47&gt; else mon_backtrace(0, 0, 0); f010006b: c7 44 24 08 00 00 00 movl $0x0,0x8(%esp) f0100072: 00 f0100073: c7 44 24 04 00 00 00 movl $0x0,0x4(%esp) f010007a: 00 f010007b: c7 04 24 00 00 00 00 movl $0x0,(%esp) f0100082: e8 18 07 00 00 call f010079f &lt;mon_backtrace&gt; cprintf("leaving test_backtrace %d\n", x); f0100087: 89 5c 24 04 mov %ebx,0x4(%esp) f010008b: c7 04 24 9c 19 10 f0 movl $0xf010199c,(%esp) f0100092: e8 97 08 00 00 call f010092e &lt;cprintf&gt; } f0100097: 83 c4 14 add $0x14,%esp f010009a: 5b pop %ebx f010009b: 5d pop %ebp f010009c: c3 ret </code></p> <p>而init()函数如下：</p> <div class="highlighter-rouge"><pre class="highlight"><code>
<span class="kt">void</span>
<span class="nf">i386_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">extern</span> <span class="kt">char</span> <span class="n">edata</span><span class="p">[],</span> <span class="n">end</span><span class="p">[];</span>

  <span class="c1">// Before doing anything else, complete the ELF loading process.
</span>  <span class="c1">// Clear the uninitialized global data (BSS) section of our program.
</span>  <span class="c1">// This ensures that all static/global variables start out zero.
</span>  <span class="n">memset</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">edata</span><span class="p">);</span>

  <span class="c1">// Initialize the console.
</span>  <span class="c1">// Can't call cprintf until after we do this!
</span>  <span class="n">cons_init</span><span class="p">();</span>

  <span class="n">cprintf</span><span class="p">(</span><span class="s">"6828 decimal is %o octal!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">6828</span><span class="p">);</span>

  <span class="c1">// Test the stack backtrace function (lab 1 only)
</span>  <span class="n">test_backtrace</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

  <span class="c1">// Drop into the kernel monitor.
</span>  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">monitor</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> <p>backtrace函数应该展示以下框架的信息：</p> <div class="highlighter-rouge"><pre class="highlight"><code>Stack backtrace:
  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031
  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061
  ...
</code></pre></div> <p>每一行包括ebp、eip和args。<br /> ebp：被函数利用的指向栈的基指针；<br /> eip：函数返回的指令指针；<br /> args：前5个arguments，在函数被调用之前被push到栈。</p> <p>第一行表示的就是正在执行的函数，也就是mon_backtrace本身，第二行反映的是调用mon_backtrace的函数，第三行表示的是调用上一行函数的函数，以此类推。你需要打印出所有的栈信息。通过学习kern/entry.S你会发现又一个容易的方法来分辨何时停止。</p> <p>该递归函数的esp和ebp如下：<br /> <code class="highlighter-rouge">c test_backtrace(5) esp: 0xf010ffc0 ebp：0xf010ffd8 test_backtrace(4) esp：0xf010ffa0 ebp：0xf010ffb8 test_backtrace(3) esp：0xf010ff80 ebp：0xf010ff98 test_backtrace(2) esp：0xf010ff60 ebp：0xf010ff78 test_backtrace(1) esp：0xf010ff40 ebp：0xf010ff58 test_backtrace(0) esp：0xf010ff20 ebp：0xf010ff38 </code></p> <blockquote> <p>练习11:实现上面的backtrace函数。用和考试一样的格式，不然会与成绩脚本冲突。运行<code class="highlighter-rouge">make grade</code>看看是否和成绩脚本一致，如果不的话要对其进行修改。</p> </blockquote> <p>此时，你的backtrace函数应该在栈上给你函数调用的地址，这个栈导致了mon_backtrace()的执行。然而你往往会想知道对应的那些地址的函数名。例如你想知道哪个函数会包含可以使内核死机的bug。</p> <p>为了帮助你实现这个功能，我们提供函数debuginfo_eip()，查看eip的符号表并返回那些地址的调试信息。这个函数在kern/kdebug.c定义了。</p> <p>这里需要实现下面的函数：</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">mon_backtrace</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Trapframe</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Your code here.
</span>  <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">ebp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span> <span class="n">read_ebp</span><span class="p">();</span>
  <span class="n">cprintf</span><span class="p">(</span><span class="s">"Stack backtrace:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">ebp</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cprintf</span><span class="p">(</span><span class="s">"ebp %x  eip %x  args"</span><span class="p">,</span> <span class="n">ebp</span><span class="p">,</span> <span class="n">ebp</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="n">cprintf</span><span class="p">(</span><span class="s">" %08.x"</span><span class="p">,</span> <span class="n">ebp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">cprintf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">ebp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span><span class="n">ebp</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> <p>这样重新make &amp;&amp; make qemu 后得到：</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="n">entering</span> <span class="n">test_backtrace</span> <span class="mi">5</span>
<span class="n">entering</span> <span class="n">test_backtrace</span> <span class="mi">4</span>
<span class="n">entering</span> <span class="n">test_backtrace</span> <span class="mi">3</span>
<span class="n">entering</span> <span class="n">test_backtrace</span> <span class="mi">2</span>
<span class="n">entering</span> <span class="n">test_backtrace</span> <span class="mi">1</span>
<span class="n">entering</span> <span class="n">test_backtrace</span> <span class="mi">0</span>
<span class="n">Stack</span> <span class="n">backtrace</span><span class="o">:</span>
<span class="n">ebp</span> <span class="n">f010ff18</span>  <span class="n">eip</span> <span class="n">f0100087</span>  <span class="n">args</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="n">f010094c</span>
<span class="n">ebp</span> <span class="n">f010ff38</span>  <span class="n">eip</span> <span class="n">f0100069</span>  <span class="n">args</span> <span class="mo">00000000</span> <span class="mo">00000001</span> <span class="n">f010ff78</span> <span class="mo">00000000</span> <span class="n">f010094c</span>
<span class="n">ebp</span> <span class="n">f010ff58</span>  <span class="n">eip</span> <span class="n">f0100069</span>  <span class="n">args</span> <span class="mo">00000001</span> <span class="mo">00000002</span> <span class="n">f010ff98</span> <span class="mo">00000000</span> <span class="n">f010094c</span>
<span class="n">ebp</span> <span class="n">f010ff78</span>  <span class="n">eip</span> <span class="n">f0100069</span>  <span class="n">args</span> <span class="mo">00000002</span> <span class="mo">00000003</span> <span class="n">f010ffb8</span> <span class="mo">00000000</span> <span class="n">f010094c</span>
<span class="n">ebp</span> <span class="n">f010ff98</span>  <span class="n">eip</span> <span class="n">f0100069</span>  <span class="n">args</span> <span class="mo">00000003</span> <span class="mo">00000004</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span>
<span class="n">ebp</span> <span class="n">f010ffb8</span>  <span class="n">eip</span> <span class="n">f0100069</span>  <span class="n">args</span> <span class="mo">00000004</span> <span class="mo">00000005</span> <span class="mo">00000000</span> <span class="mo">000100</span><span class="mi">94</span> <span class="mo">000100</span><span class="mi">94</span>
<span class="n">ebp</span> <span class="n">f010ffd8</span>  <span class="n">eip</span> <span class="n">f01000ea</span>  <span class="n">args</span> <span class="mo">00000005</span> <span class="mo">00001</span><span class="n">aac</span> <span class="mo">00000644</span> <span class="mo">00000000</span> <span class="mo">00000000</span>
<span class="n">ebp</span> <span class="n">f010fff8</span>  <span class="n">eip</span> <span class="n">f010003e</span>  <span class="n">args</span> <span class="mo">00111021</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span>
<span class="n">leaving</span> <span class="n">test_backtrace</span> <span class="mi">0</span>
<span class="n">leaving</span> <span class="n">test_backtrace</span> <span class="mi">1</span>
<span class="n">leaving</span> <span class="n">test_backtrace</span> <span class="mi">2</span>
<span class="n">leaving</span> <span class="n">test_backtrace</span> <span class="mi">3</span>
<span class="n">leaving</span> <span class="n">test_backtrace</span> <span class="mi">4</span>
<span class="n">leaving</span> <span class="n">test_backtrace</span> <span class="mi">5</span>
<span class="n">Welcome</span> <span class="n">to</span> <span class="n">the</span> <span class="n">JOS</span> <span class="n">kernel</span> <span class="n">monitor</span><span class="o">!</span>
<span class="n">Type</span> <span class="err">'</span><span class="n">help</span><span class="err">'</span> <span class="k">for</span> <span class="n">a</span> <span class="n">list</span> <span class="n">of</span> <span class="n">commands</span><span class="p">.</span>
</code></pre></div> <blockquote> <p> 练习12:修改你的栈backtrace函数，对每一eip，展示对应的函数名、源文件名、行数。 </p> </blockquote> <p>做到这里发现不懂的地方真的太多，目前也还没有好的方法去解决，接下来也许应该消化一段时间，不然一直囫囵吞枣是不行的。</p> <h4 id="section-1">最后附上一些地址和备注：</h4> <div class="highlighter-rouge"><pre class="highlight"><code><span class="mh">0xffffffff</span><span class="o">|</span><span class="mi">4</span><span class="n">GB</span>
<span class="o">----------|</span><span class="mi">32</span><span class="o">-</span><span class="n">bit</span> <span class="n">memory</span> <span class="n">mapped</span> <span class="n">devices</span>
<span class="mh">0xf0110000</span><span class="o">|</span><span class="n">bootstacktop</span> <span class="o">%</span><span class="n">esp</span>
<span class="mh">0xf0100d75</span><span class="o">|</span><span class="n">vprintfmt</span>
<span class="mh">0xf0100d4d</span><span class="o">|</span><span class="n">printfmt</span>
<span class="mh">0xf010092e</span><span class="o">|</span><span class="n">cprintf</span>                      <span class="o">==&gt;</span> <span class="err">内核代码</span>
<span class="mh">0xf01008fb</span><span class="o">|</span><span class="n">vcprintf</span>
<span class="mh">0xf010079f</span><span class="o">|</span><span class="n">mon_backtrace</span>
<span class="mh">0xf010009d</span><span class="o">|</span><span class="n">i386_init</span>
<span class="mh">0xf0100040</span><span class="o">|</span><span class="n">test_backtrace</span>
<span class="mh">0xf010000c</span><span class="o">|</span><span class="n">entry</span> <span class="n">kernel</span>
<span class="mh">0x00100000</span><span class="o">|**</span><span class="err">开始加载内核</span><span class="o">**</span>
<span class="o">----------|</span>
<span class="mh">0x000F0000</span><span class="o">|</span><span class="n">BIOS</span> <span class="n">ROM</span>
<span class="o">----------|</span><span class="mi">16</span><span class="o">-</span><span class="n">bit</span> <span class="n">expansion</span> <span class="n">ROMs</span>
<span class="mh">0x000C0000</span><span class="o">|</span>
<span class="mh">0x000A0000</span><span class="o">|</span><span class="n">VGA</span> <span class="n">Display</span>
<span class="o">----------|</span>
<span class="mh">0x00007d63</span><span class="o">|**</span><span class="err">准备将控制权交给内核</span><span class="o">**</span>
<span class="mh">0x00007d0d</span><span class="o">|</span><span class="err">进入</span><span class="n">C</span><span class="o">:</span><span class="n">bootmain</span>
<span class="mh">0x00007c45</span><span class="o">|</span><span class="err">调用</span><span class="n">bootmain</span>                 <span class="o">==&gt;</span> <span class="n">Low</span> <span class="n">Memory</span> <span class="err"> 这里是</span><span class="n">boot</span> <span class="n">loader</span><span class="err">引导程序</span>
<span class="mh">0x00007c2d</span><span class="o">|</span><span class="err">处理器切换为</span><span class="mi">32</span><span class="o">-</span><span class="n">bit</span><span class="err">模式</span>
<span class="mh">0x00007c00</span><span class="o">|</span><span class="n">boot</span><span class="err">开始的位置</span>
<span class="o">----------|</span>
<span class="mh">0x00000000</span><span class="o">|</span><span class="mi">0</span>
</code></pre></div> <p>参考资料</p> <ol> <li><a href="https://github.com/Clann24/jos/tree/master/lab1">Clann24的JOS</a></li> <li><a href="MIT 6.828 JOS学习笔记10. Lab 1 Part 3: The kernel">MIT 6.828 JOS学习笔记10. Lab 1 Part 3: The kernel</a></li> </ol> <aside class="share"> <p>If you liked this article and think others should read it, please share it on <a href="http://twitter.com/share?text=MIT6.828 Lab1 Booting a PC Part 3 exercise 9-12&amp;url=http://alvinsjq.github.io/2017/lab1_finish/&amp;via=Alvin_sjq" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">Twitter <i class="fa fa-twitter" aria-hidden="true" style="color:#00aced"></i></a>or <a href="https://www.facebook.com/sharer/sharer.php?u=http://alvinsjq.github.io/2017/lab1_finish/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=235');return false;">facebook <i class="fa fa-facebook-square" aria-hidden="true" style="color:#3b5998"></i></a>.</p> </aside> </div> <style type="text/css"> .tagged { margin-top: 1rem; } .tagged a { border: 1px solid #ddd; padding: 2px 5px; background: transparent; display: inline-block; color: #999; outline: 0; text-decoration: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; font-size: 70%; } .tagged a:hover { cursor: pointer; border: 1px solid #555; background: #444; color: #fff; } .back { /*text-align: center;*/ text-transform: uppercase; letter-spacing: 1px; } </style> <div class="tagged"> <a href="http://alvinsjq.github.io/tagged#mit6-828"><i class="fa fa-hashtag" aria-hidden="true"></i>MIT6.828</a> <a href="http://alvinsjq.github.io/tagged#operating-system"><i class="fa fa-hashtag" aria-hidden="true"></i>Operating System</a> <a href="http://alvinsjq.github.io/tagged#操作系统"><i class="fa fa-hashtag" aria-hidden="true"></i>操作系统</a> <a href="http://alvinsjq.github.io/tagged#学习历程"><i class="fa fa-hashtag" aria-hidden="true"></i>学习历程</a> <a href="http://alvinsjq.github.io/tagged#kernel"><i class="fa fa-hashtag" aria-hidden="true"></i>kernel</a> </div> <br> <div class="back"><a href="/"><i class="fa fa-chevron-left"></i>Back</a></div> </article> <aside id="comments" class="disqus"> <div class="container"> <div id="gitmentContainer"></div> <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"> <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script> <script> var gitment = new Gitment({ id: '<%= page.title %>', owner: 'Alvinsjq', repo: 'Alvinsjq.github.io', oauth: { client_id: 'b108345cd65235055f4a', client_secret: '2faaebf58d2e33a50a022d84c6448d9d9535feda', }, }); gitment.render('gitmentContainer'); </script> </div> </aside> <footer class="site-footer"> <div class="container"> <small class="block">&copy; 2018 Alvinsjq. All rights reserved.</small> <small><a href="https://github.com/heiswayi/thinkspace">Thanks for <i class="fa fa-heart" aria-hidden="true" style="color:#DD3D36"></i> Thinkspace</a> theme by <a href="http://heiswayi.github.io/">Heiswayi Nrird</a>.</small> <div class="footer-social-links"> <a href="http://alvinsjq.github.io/feed.xml" title="RSS Feed" target="_blank"><i class="fa fa-rss"></i></a> <a href="http://weibo.com/p/1005051719812480/home" title="Weibo" target="_blank"><i class="fa fa-weibo" aria-hidden="true"></i></a> <a href="https://twitter.com/Alvin_sjq" title="Twitter" target="_blank"><i class="fa fa-twitter"></i></a> <a href="https://github.com/Alvinsjq/" title="GitHub Repositories" target="_blank"><i class="fa fa-github-alt"></i></a> <a href="https://www.instagram.com/sj_alvin/" title="Instagram" target="_blank"><i class="fa fa-instagram"></i></a> </div> </div> </footer> </main> </body> </html>
