<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta name="apple-mobile-web-app-capable" content="yes"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> MIT6.828 Lab 2 : Memory Management | Alvin Is </title> <!-- Icons --> <link rel="apple-touch-icon" type=" image/png" sizes="144x144" href="assets/images/webicon.png"> <link rel="icon" type=" image/png" href="/assets/images/webicon_32.png"> <link rel="shortcut icon" type=" image/png" href="/assets/images/webicon_32.png"> <meta name="description" content=" 关于操作系统的用户级进程... "> <meta name="keywords" content=""> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <!-- Social: Facebook / Open Graph --> <meta property="og:type" content="article"> <meta property="article:author" content="Alvinsjq"> <meta property="article:section" content=""> <meta property="article:tag" content=""> <meta property="article:published_time" content="2017-02-27 14:40:22 +0800"> <meta property="og:url" content="http://alvinsjq.github.io/2017/mit6828-lab2/"> <meta property="og:title" content=" MIT6.828 Lab 2 : Memory Management | Alvin Is "> <meta property="og:image" content="http://alvinsjq.github.io"> <meta property="og:description" content=" 关于操作系统的用户级进程... "> <meta property="og:site_name" content="Alvinsjq"> <meta property="og:locale" content="en_US"> <!-- Social: Twitter --> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:site" content="@Alvin_sjq"> <meta name="twitter:title" content=" MIT6.828 Lab 2 : Memory Management | Alvin Is "> <meta name="twitter:description" content=" 关于操作系统的用户级进程... "> <meta name="twitter:image:src" content="http://alvinsjq.github.io"> <!-- Social: Google+ / Schema.org --> <meta itemprop="name" content=" MIT6.828 Lab 2 : Memory Management | Alvin Is "> <meta itemprop="description" content=" 关于操作系统的用户级进程... "> <meta itemprop="image" content="http://alvinsjq.github.io"> <!-- rel prev and next --> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/font-awesome.min.css"> <!-- Canonical link tag --> <link rel="canonical" href="http://alvinsjq.github.io/2017/mit6828-lab2/"> <link rel="alternate" type="application/rss+xml" title="Alvin Is" href="http://alvinsjq.github.io/feed.xml"> <script type="text/javascript"> var disqus_shortname = 'alvin-is'; var _gaq = _gaq || []; _gaq.push(['_setAccount', '']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); </script> <script src="https://code.jquery.com/jquery-3.2.0.min.js"></script> <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script> <script>AV.initialize("OfIL1RlM4M4n30dWx3wXlEIz-gzGzoHsz", "LlDtB3Xu9be1655lnGQdPedO");</script> <script> function showHitCount(Counter) { var query = new AV.Query(Counter); var entries = []; var $visitors = $(".leancloud_visitors"); $visitors.each(function () { entries.push( $(this).attr("id").trim() ); }); query.containedIn('url', entries); query.find() .done(function (results) { var COUNT_CONTAINER_REF = '.leancloud-visitors-count'; if (results.length === 0) { $visitors.find(COUNT_CONTAINER_REF).text(0); return; } for (var i = 0; i < results.length; i++) { var item = results[i]; var url = item.get('url'); var hits = item.get('hits'); var element = document.getElementById(url); $(element).find(COUNT_CONTAINER_REF).text(hits); } for(var i = 0; i < entries.length; i++) { var url = entries[i]; var element = document.getElementById(url); var countSpan = $(element).find(COUNT_CONTAINER_REF); if( countSpan.text() == '') { countSpan.text(0); } } }) .fail(function (object, error) { console.log("Error: " + error.code + " " + error.message); }); } function addCount(Counter) { var $visitors = $(".leancloud_visitors"); var url = $visitors.attr('id').trim(); var title = $visitors.attr('data-flag-title').trim(); var query = new AV.Query(Counter); query.equalTo("url", url); query.find({ success: function(results) { if (results.length > 0) { var counter = results[0]; counter.fetchWhenSave(true); counter.increment("hits"); counter.save(null, { success: function(counter) { var $element = $(document.getElementById(url)); $element.find('.leancloud-visitors-count').text(counter.get('hits')); }, error: function(counter, error) { console.log('Failed to save Visitor num, with error message: ' + error.message); } }); } else { var newcounter = new Counter(); var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); newcounter.setACL(acl); newcounter.set("title", title); newcounter.set("url", url); newcounter.set("hits", 1); newcounter.save(null, { success: function(newcounter) { var $element = $(document.getElementById(url)); $element.find('.leancloud-visitors-count').text(newcounter.get('hits')); }, error: function(newcounter, error) { console.log('Failed to create'); } }); } }, error: function(error) { console.log('Error:' + error.code + " " + error.message); } }); } $(function() { var Counter = AV.Object.extend("Counter"); if ($('.leancloud_visitors').length == 1) { addCount(Counter); } else if ($('.post-link').length > 1){ showHitCount(Counter); } }); </script> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?011d93aa32b263cf21d7c9a15165b8a0"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> </head> <body> <main class="wrapper"> <header class="site-header"> <nav class="nav"> <div class="container"> <h1 class="logo"><a href="/">Alvin Is<span></span></a></h1> <ul class="navbar"> <li><a href="/about">About</a></li> <li><a href="/talks">Topics</a></li> <li><a href="/archives">Archives</a></li> <li><a href="/feed.xml" target="_blank"></a></li> </ul> </div> </nav> </header> <article class="post container" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"> <p class="post-meta"><time datetime="2017-02-27T14:40:22+08:00" itemprop="datePublished">Feb 27, 2017</time> <span id="/2017/mit6828-lab2/" class="leancloud_visitors" data-flag-title="MIT6.828 Lab 2 : Memory Management"> <span class="post-meta-divider">|</span> <span class="post-meta-item-text"> 浏览次数: </span> <span class="leancloud-visitors-count"></span> </span> </p> <h1 class="post-title" itemprop="name headline">MIT6.828 Lab 2 : Memory Management</h1> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } }); </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } }); </script> <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> </header> <div class="post-content" itemprop="articleBody"> <ul> <li>Part 1: Physical Page Management</li> <li>Part 2: Virtual Memory</li> <li>Part 3: Kernel Address Space</li> </ul> <h4 id="section">导言</h4> <p>内存管理的两部分：内核物理地址的分配器、虚拟内存。</p> <p>内核物理地址分配可以使内核能过分配内存并在之后释放内存，也就使Pages，占4096bytes单元。</p> <p>虚拟内存将内核以及用户软件利用的虚拟地址映射到物理内存地址。当指令在利用内存时，设置MMU，然后得到页表。</p> <p>任务：</p> <ul> <li>维护记录物理pages空闲和已分配的数据结构，写出分配和释放内存的页的过程。</li> <li>根据提供的说明建立MMU的页表来改造JOS。</li> </ul> <h4 id="section-1">实验准备</h4> <p>实验2新加了以下几个源文件：</p> <ol> <li>inc/memlayout.h 虚拟地址空间的布局（通过修改2实现）</li> <li>kern/pmap.c 阅读这个设备硬件，以便弄清有多少物理地址，不过这部分已经写好了，因为不需要知道CMOS硬件工作的细节</li> <li>kern/pmap.h 定义PageInfo结构，它可以追踪哪个物理内存的页是空闲的</li> <li>kern/kclock.h 4和5操作着PC的电子时钟和CMOS RAM硬件</li> <li>kern/kclock.c</li> </ol> <p>1和3需要都知道它们中的定义，也许还要看inc/mmu.h</p> <h4 id="section-2">第一部分：物理页管理</h4> <p>操作系统必须追踪哪部分物理RAM是空闲的、正在使用的。JOS用page granularity来管理物理内存以便它可以使用MMU（硬件内存管理单元）去映射和保护分配的内存的每一块。</p> <p>这部分要写的是物理页的分配器。它可以在struct PageInfo 对象（每一个对象代表一个物理页）的一个链接列表得到那些页是空闲的，在实现虚拟地址之前先要完成这个，因为页表管理需要分配储存在页表中的物理内存。</p> <blockquote> <p>练习1:In the file kern/pmap.c, you must implement code for the following functions (probably in the order given)：</p> </blockquote> <div class="highlighter-rouge"><pre class="highlight"><code>boot_alloc()
mem_init() (only up to the call to check_page_free_list(1))
page_init()
page_alloc()
page_free()
</code></pre></div> <blockquote> <p>check_page_free_list() and check_page_alloc() test your physical page allocator. You should boot JOS and see whether check_page_alloc() reports success. Fix your code so that it passes. You may find it helpful to add your own assert()s to verify that your assumptions are correct.</p> </blockquote> <p>这个练习是要完成以上列出的几个函数，根据kern/pmap.c中的注释，可以一步一步了解到其中每个函数的功能和实现的细节。</p> <p>操作系统要在UTOP上面设置虚拟地址的内存映射，在关于<a href="https://alvinsjq.github.io/2017/process-overview/">Page tables</a>的博文中也提到需要建立两层的页表。而函数mem_init()就是主要做这个工作。阅读代码发现，首先需要知道机器有多少内存，这可以通过函数通过i386_detect_memory()得到。紧接着就是要创建初始表（initial page），这就要实现boot_alloc()。</p> <p><strong>boot_alloc()</strong></p> <p>boot_alloc()并不是真正的physical memory allocator，它仅仅是当JOS设置它的虚拟内存系统的时候才来分配，真正的分配器函数是page_alloc()。</p> <p>在注释中，也说的很清楚，如果n&gt;0，那么就分配足够装下n个字节的页出来；如果n==0，那么就返回下一个空闲页的地址，而不进行分配；这个函数只会在初始化时，在page_free_list建立好之前利用。这里的n就是该函数的参数。</p> <p>因此在该函数就需要考虑n不为0对时候，维护好参数nextfree，这里ROUNDUP就是寻找离nextfree+n最近的且地址高于nextfree的可以整除PGSIZE的地址，更新nextfree，然后返回结果就可以了:</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">boot_alloc</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">nextfree</span><span class="p">;</span>  <span class="c1">// virtual address of next byte of free memory
</span>    <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nextfree</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">extern</span> <span class="kt">char</span> <span class="n">end</span><span class="p">[];</span>
        <span class="n">nextfree</span> <span class="o">=</span> <span class="n">ROUNDUP</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">end</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Allocate a chunk large enough to hold 'n' bytes, then update
</span>    <span class="c1">// nextfree.  Make sure nextfree is kept aligned
</span>    <span class="c1">// to a multiple of PGSIZE.
</span>    <span class="c1">//
</span>    <span class="c1">// LAB 2: Your code here.
</span>    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">nextfree</span> <span class="o">=</span> <span class="n">ROUNDUP</span><span class="p">(</span><span class="n">nextfree</span><span class="o">+</span><span class="n">n</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span><span class="k">else</span>
        <span class="k">return</span> <span class="n">nextfree</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> <p>然后在mem_init()中，就要为系统分配npages存储在页中，作用就是内核利用它来追踪物理页，对于每一个物理页，都有一个对应的结构PageInfo。这里的npages指的就是内存中的物理页的数量。</p> <div class="highlighter-rouge"><pre class="highlight"><code>    <span class="c1">// Your code goes here:
</span>    <span class="n">pages</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="p">)</span> <span class="n">boot_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">PageInfo</span><span class="p">)</span> <span class="o">*</span> <span class="n">npages</span><span class="p">);</span>

    <span class="n">cprintf</span><span class="p">(</span><span class="s">"npages: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">npages</span><span class="p">);</span>
    <span class="n">cprintf</span><span class="p">(</span><span class="s">"npages_basemem: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">npages_basemem</span><span class="p">);</span>
    <span class="n">cprintf</span><span class="p">(</span><span class="s">"pages: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
</code></pre></div> <p>那么在mem_init()函数中怎样追踪物理页呢？就要用到下面的一些函数。每个物理页都会有一个Pageinfo结构。</p> <p><strong>page_init()</strong><br /> 一旦这个函数完成，自然就不会再用到boot_alloc了。在外面分配好初始内核的数据结构后，我们就要设置物理页的list。一旦这个做好，之后所有的内存管理都将通过page_*函数。我们现在就可以用boot_map_region或者page_insert来映射内存。</p> <p>该函数的功能有：</p> <ul> <li>初始化pages数组</li> <li>初始化pages_free_list链表</li> </ul> <p>整个函数是由一个for循环构成，它会遍历所有内存页所对应的在npages数组中的PageInfo结构体，并且根据这个页当前的状态来修改这个结构体的状态。<br /> 如果页已被占用，那么要把PageInfo结构体中的pp_ref属性置1；<br /> 如果是空闲页，则要把这个页送入pages_free_list链表中；<br /> 根据注释中的提示，第0页已被占用，io hole部分已被占用，还有extended memory区域的一部分也已经被占用</p> <div class="highlighter-rouge"><pre class="highlight"><code>    <span class="kt">void</span>
<span class="nf">page_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">page_free_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">//num_extmem_alloc：在extmem区域已经被占用的页的个数
</span>    <span class="kt">int</span> <span class="n">num_extmem_alloc</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">boot_alloc</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">KERNBASE</span><span class="p">)</span> <span class="o">/</span> <span class="n">PGSIZE</span><span class="p">;</span>
    <span class="c1">//num_iohole：在io hole区域占用的页数
</span>    <span class="kt">int</span> <span class="n">num_iohole</span> <span class="o">=</span> <span class="p">(</span><span class="n">EXTPHYSMEM</span> <span class="o">-</span> <span class="n">IOPHYSMEM</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGESIZE</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">npages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>    
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">npages_basemem</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages_basemem</span> <span class="o">+</span> <span class="n">num_iohole</span> <span class="o">+</span> <span class="n">num_alloc</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_link</span> <span class="o">=</span> <span class="n">page_free_list</span><span class="p">;</span>
            <span class="n">page_free_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> <p>然后就利用check_page_free_list来检测page_free_list是否合理。这个检查完后，将进入下一个检查函数check_page_alloc()，这个函数的功能是检查分配器函数中page_alloc()，page_free()两个子函数是否能够正确运行。所以我们首先要实现这两个子函数。</p> <p>这两个代码的实现就是：</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 分配一个物理页
</span><span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span>
<span class="nf">page_alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">page_free_list</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">page_free_list</span><span class="p">;</span>
        <span class="n">page_free_list</span> <span class="o">=</span> <span class="n">page_free_list</span><span class="o">-&gt;</span><span class="n">pp_link</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_ZERO</span><span class="p">)</span> 
            <span class="n">memset</span><span class="p">(</span><span class="n">page2kva</span><span class="p">(</span><span class="n">ret</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//
// 返回给free list一个页
// (This function should only be called when pp-&gt;pp_ref reaches 0.)
//
</span><span class="kt">void</span>
<span class="nf">page_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="n">pp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_link</span> <span class="o">=</span> <span class="n">page_free_list</span><span class="p">;</span>
    <span class="n">page_free_list</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> <p>这样就完成了第一部分的实验。</p> <h4 id="section-3">第二部分：虚拟内存</h4> <blockquote> <p>练习2:阅读80386 Programmer’s Reference Manual的对应章节。</p> </blockquote> <p>这里主要是讲了Page translation和Page-Level Protection，大部分内容和<a href="https://alvinsjq.github.io/2017/process-overview/">Page tables</a>相似，可以看一下。</p> <p>在x86上，一个虚拟地址是由一个segment selector 和一个offset组成的。一个linear address 是介于segmentation机制和paging机制之间的地址，也就是在虚拟地址转换之后的一种地址，再被paging转换一次就可以映射到物理地址了。而物理地址就是最终的硬件上的地址。</p> <div class="highlighter-rouge"><pre class="highlight"><code>        Selector  +--------------+         +-----------+
       ----------&gt;|              |         |           |
                  | Segmentation |         |  Paging   |  Software             |              |--------&gt;|           |----------&gt;  RAM
         Offset   |  Mechanism   |         | Mechanism |
       ----------&gt;|              |         |           |
                  +--------------+         +-----------+
         Virtual                   Linear                Physical
</code></pre></div> <p>在boot／boot.S中，我们安装了一个全局描述表(GDT)，使得段地址转换失效，并且将段基址设置为0，并限制到0xffffffff。因此，selector就没有用了，所以其虚拟地址的offset就是它的linear address。</p> <p>在实验1的第三部分，我们设置了一个简单的页表使得内核可以在它的链接地址0xf0100000运行，尽管它实际上就是加载在ROM BIOS之上的物理地址0x00100000之上。这个页表仅仅映射了4MB的地址，在这次实验中，要将其扩展到256MB的物理内存（从虚拟地址0xf0000000开始）。</p> <blockquote> <p>练习3:While GDB can only access QEMU’s memory by virtual address, it’s often useful to be able to inspect physical memory while setting up virtual memory. Review the QEMU monitor commands from the lab tools guide, especially the xp command, which lets you inspect physical memory. To access the QEMU monitor, press Ctrl-a c in the terminal (the same binding returns to the serial console).<br /> Use the xp command in the QEMU monitor and the x command in GDB to inspect memory at corresponding physical and virtual addresses and make sure you see the same data.<br /> Our patched version of QEMU provides an info pg command that may also prove useful: it shows a compact but detailed representation of the current page tables, including all mapped memory ranges, permissions, and flags. Stock QEMU also provides an info mem command that shows an overview of which ranges of virtual memory are mapped and with what permissions.</p> </blockquote> <p>从代码在CPU上执行，一旦我们进入到保护模式，就不能直接使用linear address或物理地址了。所有内存都由MMU被视为虚拟地址，也就是说在C中的指针其实都是虚拟地址。</p> <p>在JOS中，例如物理内存分配器，会使用到地址类型，这里有一个总结：</p> <table> <thead> <tr> <th>C type</th> <th>Address type</th> </tr> </thead> <tbody> <tr> <td>T*</td> <td>Virtual</td> </tr> <tr> <td>uintptr_t</td> <td>Virtual</td> </tr> <tr> <td>physaddr_t</td> <td>Physical</td> </tr> </tbody> </table> <p>JOS有时需要读取或者修改内存，且想要通过物理地址的方式。然而，内核和其他软件一样，不能跳过虚拟地址转换，因此不能够直接加载和存储到物理地址中去。为了能转换一个物理地址到一个内核能读写虚拟地址，内核必须在物理地址上加上0xf0000000来找到对应的虚拟地址，可以使用KADDR(pa)完成。</p> <p>相反，JOS有时也需要从一个虚拟地址得到一个物理地址，那么就需要减去0xf0000000，可以用PADDR(va)来完成操作。</p> <blockquote> <p>练习4:In the file kern/pmap.c, you must implement code for the following functions.</p> </blockquote> <div class="highlighter-rouge"><pre class="highlight"><code>        pgdir_walk()
        boot_map_region()
        page_lookup()
        page_remove()
        page_insert()
</code></pre></div> <blockquote> <p>check_page(), called from mem_init(), tests your page table management routines. You should make sure it reports success before proceeding.</p> </blockquote> <p>接下来就是一步一步去实现这些函数，</p> <ol> <li>pgdir_walk()</li> </ol> <p>给定一个‘pgdir’，这是一个指向一个page directory的指针，pgdir_walk函数返回线性地址所对应的page table entry指针，这需要通过两层页表结构。</p> <p>相关的页表page可能不存在，如果它是true，并且create==false，那么返回NULL。<br /> 否则，函数用page_alloc分配一个新的page table page：<br /> 如果分配失败了，函数返回NULL；<br /> 否则，新的page reference就会自增，然后该page被清理并且函数返回一个指向新页表的指针。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// Hint 1: you can turn a Page * into the physical address of the
// page it refers to with page2pa() from kern/pmap.h.
//
// Hint 2: the x86 MMU checks permission bits in both the page directory
// and the page table, so it's safe to leave permissions in the page
// more permissive than strictly necessary.
//
// Hint 3: look at inc/mmu.h for useful macros that mainipulate page
// table and page directory entries.
//
</span><span class="n">pte_t</span> <span class="o">*</span>
<span class="nf">pgdir_walk</span><span class="p">(</span><span class="n">pde_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">dindex</span> <span class="o">=</span> <span class="n">PDX</span><span class="p">(</span><span class="n">va</span><span class="p">),</span> <span class="n">tindex</span> <span class="o">=</span> <span class="n">PTX</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
    <span class="c1">//dir index, table index
</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pgdir</span><span class="p">[</span><span class="n">dindex</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">PTE_P</span><span class="p">))</span> <span class="p">{</span> <span class="c1">//if pde not exist
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">create</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="n">pg</span> <span class="o">=</span> <span class="n">page_alloc</span><span class="p">(</span><span class="n">ALLOC_ZERO</span><span class="p">);</span>   <span class="c1">//alloc a zero page
</span>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pg</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>   <span class="c1">//allocation fails
</span>            <span class="n">pg</span><span class="o">-&gt;</span><span class="n">pp_ref</span><span class="o">++</span><span class="p">;</span>
            <span class="n">pgdir</span><span class="p">[</span><span class="n">dindex</span><span class="p">]</span> <span class="o">=</span> <span class="n">page2pa</span><span class="p">(</span><span class="n">pg</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_P</span> <span class="o">|</span> <span class="n">PTE_U</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">pte_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">KADDR</span><span class="p">(</span><span class="n">PTE_ADDR</span><span class="p">(</span><span class="n">pgdir</span><span class="p">[</span><span class="n">dindex</span><span class="p">]));</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">+</span><span class="n">tindex</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> <p>2.boot_map_region()</p> <p>在页表根pgdir上，将虚拟地址[va, va+size)映射到[pa, pa+size)。大小是两倍的PGSIZE。<br /> 并且PTE_P允许。<br /> 这个函数仅是设置在UTOP之上的‘静态’映射，因此，它不会改变在mapped pages上的pp_ref区域。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// Hint: the TA solution uses pgdir_walk
</span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">boot_map_region</span><span class="p">(</span><span class="n">pde_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">va</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">physaddr_t</span> <span class="n">pa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">cprintf</span><span class="p">(</span><span class="s">"Virtual Address %x mapped to Physical Address %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">pa</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">/</span><span class="n">PGSIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">va</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">pa</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">pgdir_walk</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">va</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//create
</span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span> <span class="n">panic</span><span class="p">(</span><span class="s">"boot_map_region panic, out of memory"</span><span class="p">);</span>
        <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">pa</span> <span class="o">|</span> <span class="n">perm</span> <span class="o">|</span> <span class="n">PTE_P</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cprintf</span><span class="p">(</span><span class="s">"Virtual Address %x mapped to Physical Address %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">pa</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div> <ol> <li>page_lookup()</li> </ol> <p>返回映射在虚拟地址‘va’上的page。<br /> 如果pte_store不为0，那就将该页pte的地址存在那。它可以被page_remove使用，并且能被用来验证对系统调用参数的page permission并且大多使得调用者不能使用。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// Return NULL if there is no page mapped at va.
//
// Hint: the TA solution uses pgdir_walk and pa2page.
//
</span><span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span>
<span class="nf">page_lookup</span><span class="p">(</span><span class="n">pde_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">**</span><span class="n">pte_store</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">pgdir_walk</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">//not create
</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_P</span><span class="p">))</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>   <span class="c1">//page not found
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">pte_store</span><span class="p">)</span>
        <span class="o">*</span><span class="n">pte_store</span> <span class="o">=</span> <span class="n">pte</span><span class="p">;</span>   <span class="c1">//found and set
</span>    <span class="k">return</span> <span class="n">pa2page</span><span class="p">(</span><span class="n">PTE_ADDR</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>     
<span class="p">}</span>
</code></pre></div> <ol> <li>page_remove()</li> </ol> <p>解除在虚拟地址‘va’上的物理页的映射。如果在该地址没有物理页，那就不做什么。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// Hint: The TA solution is implemented using page_lookup,
//  tlb_invalidate, and page_decref.
//
</span><span class="kt">void</span>
<span class="nf">page_remove</span><span class="p">(</span><span class="n">pde_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="n">pg</span> <span class="o">=</span> <span class="n">page_lookup</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pte</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pg</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_P</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span> <span class="c1">//page not exist
//   - The ref count on the physical page should decrement.
//   - The physical page should be freed if the refcount reaches 0.
</span>    <span class="n">page_decref</span><span class="p">(</span><span class="n">pg</span><span class="p">);</span>
<span class="c1">//   - The pg table entry corresponding to 'va' should be set to 0.
</span>    <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">//   - The TLB must be invalidated if you remove an entry from
//     the page table.
</span>    <span class="n">tlb_invalidate</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">va</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> <ol> <li>page_insert()</li> </ol> <p>将物理页‘pp’映射到虚拟地址‘va’。</p> <p>需要：<br /> 如果已经有一个page映射到了‘va’，把要用page_remove()；<br /> 如果按照要求需要的，那么也表就应该被分配并且被插入到‘pgdir’；<br /> 如果插入成功，那么pp-&gt;pp_ref就需要自增；<br /> 如果一个page之前就在‘va’，那么TLB就得失效。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// The permissions (the low 12 bits) of the page table entry
// should be set to 'perm|PTE_P'.
// Corner-case hint: Make sure to consider what happens when the same
// pp is re-inserted at the same virtual address in the same pgdir.
// However, try not to distinguish this case in your code, as this
// frequently leads to subtle bugs; there's an elegant way to handle
// everything in one code path.
//
// RETURNS:
//   0 on success
//   -E_NO_MEM, if page table couldn't be allocated
//
// Hint: The TA solution is implemented using pgdir_walk, page_remove,
// and page2pa.
//
</span><span class="kt">int</span>
<span class="nf">page_insert</span><span class="p">(</span><span class="n">pde_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="kt">int</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">pgdir_walk</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">//create on demand
</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span>   <span class="c1">//page table not allocated
</span>        <span class="k">return</span> <span class="o">-</span><span class="n">E_NO_MEM</span><span class="p">;</span>   
    <span class="c1">//increase ref count to avoid the corner case that pp is freed before it is inserted.
</span>    <span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_ref</span><span class="o">++</span><span class="p">;</span>   
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_P</span><span class="p">)</span>   <span class="c1">//page colides, tle is invalidated in page_remove
</span>        <span class="n">page_remove</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">va</span><span class="p">);</span>
    <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">page2pa</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="o">|</span> <span class="n">perm</span> <span class="o">|</span> <span class="n">PTE_P</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> <h4 id="section-4">第三部分：内核地址空间</h4> <p>JOS把32位线性地址虚拟空间划分成两个部分。其中用户环境（进程运行环境）通常占据低地址的那部分，叫用户地址空间。而操作系统内核总是占据高地址的部分，叫内核地址空间。这两个部分的分界线是定义在memlayout.h文件中的一个宏 ULIM。JOS为内核保留了接近256MB的虚拟地址空间。这就可以理解了，为什么在实验1中要给操作系统设计一个高地址的地址空间。如果不这样做，用户环境的地址空间就不够了。</p> <p><strong>许可和错误隔离</strong></p> <p>由于内核和用户进程只能访问各自的地址空间，所以我们必须在x86页表中使用访问权限位(Permission Bits)来使用户进程的代码只能访问用户地址空间，而不是内核地址空间。否则用户代码中的一些错误可能会覆写内核中的数据，最终导致内核的崩溃。</p> <p>处在用户地址空间中的代码不能访问高于ULIM的地址空间，但是内核可以读写这部分空间。而内核和用户对于地址范围[UTOP, ULIM]有着相同的访问权限，那就是可以读取但是不可以写入。这一个部分的地址空间通常被用于把一些只读的内核数据结构暴露给用户地址空间的代码。在UTOP之下的地址范围是给用户进程使用的，用户进程可以访问，修改这部分地址空间的内容。</p> <p><strong>初始化内核地址空间</strong></p> <p>现在我们要设置一下UTOP之上的地址空间：这也是整个虚拟地址空间中的内核地址空间部分。inc/memlayout.h文件中已经向你展示了这部分地址空间的布局。你可以使用你刚刚编写的函数来设置这些地址的布局。</p> <blockquote> <p>练习5:Fill in the missing code in mem_init() after the call to check_page().<br /> Your code should now pass the check_kern_pgdir() and check_page_installed_pgdir() checks.</p> </blockquote> <p>UPAGES:<br /> 首先我们要映射的范围是把pages数组映射到线性地址UPAGES，大小为一个PTSIZE。</p> <div class="highlighter-rouge"><pre class="highlight"><code>    <span class="n">boot_map_region</span><span class="p">(</span><span class="n">kern_pgdir</span><span class="p">,</span> 
        <span class="n">UPAGES</span><span class="p">,</span> 
        <span class="n">PTSIZE</span><span class="p">,</span> 
        <span class="n">PADDR</span><span class="p">(</span><span class="n">pages</span><span class="p">),</span> 
        <span class="n">PTE_U</span><span class="p">);</span>
</code></pre></div> <p>BOOTSTACK:<br /> 然后映射内核的堆栈区域，把由bootstack变量所标记的物理地址范围映射给内核的堆栈。内核堆栈的虚拟地址范围是[KSTACKTOP-PTSIZE, KSTACKTOP)，不过要把这个范围划分成两部分：</p> <p>　　　　* [KSTACKTOP-KSTKSIZE, KSTACKTOP) 这部分映射关系加入的页表中。</p> <p>　　　　* [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) 这部分不进行映射。</p> <p>对这部分地址的访问权限是，kernel space 可以读写，user space 无权访问</p> <div class="highlighter-rouge"><pre class="highlight"><code>    <span class="n">boot_map_region</span><span class="p">(</span><span class="n">kern_pgdir</span><span class="p">,</span> 
        <span class="n">KSTACKTOP</span><span class="o">-</span><span class="n">KSTKSIZE</span><span class="p">,</span> 
        <span class="n">KSTKSIZE</span><span class="p">,</span> 
        <span class="n">PADDR</span><span class="p">(</span><span class="n">bootstack</span><span class="p">),</span> 
        <span class="n">PTE_W</span><span class="p">);</span>
</code></pre></div> <p>KERNBASE：<br /> 最后映射整个操作系统内核，虚拟地址范围是[KERNBASE, 2^32]，物理地址范围是[0，2^32 - KERNBASE]。<br /> 访问权限是，kernel space 可以读写，user space 无权访问：</p> <div class="highlighter-rouge"><pre class="highlight"><code>    <span class="n">boot_map_region</span><span class="p">(</span><span class="n">kern_pgdir</span><span class="p">,</span> 
        <span class="n">KERNBASE</span><span class="p">,</span> 
        <span class="o">-</span><span class="n">KERNBASE</span><span class="p">,</span> 
        <span class="mi">0</span><span class="p">,</span> 
        <span class="n">PTE_W</span><span class="p">);</span>
</code></pre></div> <p><strong>问题</strong>：</p> <ol> <li>到目前为止页目录表中已经包含多少有效页目录项？他们都映射到哪里？</li> </ol> <table> <thead> <tr> <th>Entry</th> <th>Base</th> <th>Virtual Address Points to (logically)</th> </tr> </thead> <tbody> <tr> <td>1023</td> <td>0xffc00000</td> <td>Page table for top 4MB of phys mem</td> </tr> <tr> <td>1022</td> <td>0xff800000</td> <td>.</td> </tr> <tr> <td>.</td> <td>.</td> <td>.</td> </tr> <tr> <td>960</td> <td>KERNBASE (0xf0000000)</td> <td>Page table for low 4MB of phys mem</td> </tr> <tr> <td>959</td> <td>VPT (0xefc00000)</td> <td>Page directory (kernel-only, R/W)</td> </tr> <tr> <td>958</td> <td>ULIM (0xef800000)</td> <td>Page table mapping kernel stack</td> </tr> <tr> <td>957</td> <td>UVPT (0xef400000)</td> <td>Page directory (kernel/user, R-O)</td> </tr> <tr> <td>956</td> <td>UPAGES (0xef000000)</td> <td>Page table mapping “pages” array</td> </tr> <tr> <td>955</td> <td>UTOP,UENVS (0xeec00000)</td> <td>Page table mapping “envs” array</td> </tr> <tr> <td>954</td> <td>.</td> <td>Nothing mapped</td> </tr> <tr> <td>.</td> <td>.</td> <td>.</td> </tr> <tr> <td>2</td> <td>0x00800000</td> <td>.</td> </tr> <tr> <td>1</td> <td>0x00400000</td> <td>.</td> </tr> <tr> <td>0</td> <td>0x00000000</td> <td>Nothing mapped</td> </tr> </tbody> </table> <ol> <li>我们把kernel和user environment放在一个相同的地址空间中。为什么用户程序不能读写内核的内存空间？用什么机制保护内核的地址范围。</li> </ol> <p>通过ULIM和UTOP，虚拟内存被分成段。(ULIM, 4GB) 的地址仅是内核的，而(UTOP, ULIM]是内核与用户都能读取的空间，而[0x0, UTOP] 是用户的空间。这些内存空间是由permission位保护的，例如设置在页表或页表目录中的flags：PTE_W (writeable) and PTE_U (user)。<br /> 具体的保护机制就是CPL（Current Privilege Level ），这是%cs的最低2位：<br /> CPL=0，OS特权<br /> CPL=3，user特权<br /> 这可以用来检测当前的模式，以及此时是否可以对虚拟内存地址进行读写。</p> <ol> <li>这个操作系统的可以支持的最大数量的物理内存是多大？为什么？</li> </ol> <p>从文件kern/pmap.h可以知道该操作系统能够支持的最大物理内存是256M。由于这个操作系统利用一个大小为4MB的空间UPAGES来存放所有的页的PageInfo结构体信息，每个结构体的大小为8B，所以一共可以存放512K个PageInfo结构体，所以一共可以出现512K个物理页，每个物理页大小为4KB，自然总的物理内存占2GB。</p> <ol> <li>如果现在的物理内存页达到最大个数，那么管理这些内存所需要的额外空间开销有多少？　　</li> </ol> <p>若我们有2GB的物理内存，我们需要4M用来存放所有的pageInfo来管理内存，2MB为了Page table Table和4KB的页表目录，总共就是6MB+4KB。</p> <ol> <li>回顾entry.S文件中，当分页机制开启时，寄存器EIP的值仍旧是一个小的值。在哪个位置代码才开始运行在高于KERNBASE的虚拟地址空间中的？当程序位于开启分页之后到运行在KERNBASE之上这之间的时候，EIP的值是小的值，怎么保证可以把这个值转换为真实物理地址的？</li> </ol> <p>在entry.S文件中有一个指令 jmp *%eax，这个指令要完成跳转，就会重新设置EIP的值，把它设置为寄存器eax中的值，而这个值是大于KERNBASE的，所以就完成了EIP从小的值到大于KERNBASE的值的转换。</p> <p>在entry_pgdir这个页表中，也把虚拟地址空间[0, 4MB)映射到物理地址空间[0, 4MB)上，所以当访问位于[0, 4MB)之间的虚拟地址时，可以把它们转换为物理地址。</p> <h4 id="section-5">参考资料</h4> <p>[1]. https://github.com/Clann24/jos/tree/master/lab2/code</p> <p>[2]. http://www.cnblogs.com/fatsheep9146/p/5124921.html</p> <p>[3]. http://www.cnblogs.com/fatsheep9146/p/5324692.html</p> <aside class="share"> <p>If you liked this article and think others should read it, please share it on <a href="http://twitter.com/share?text=MIT6.828 Lab 2 : Memory Management&amp;url=http://alvinsjq.github.io/2017/mit6828-lab2/&amp;via=Alvin_sjq" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">Twitter <i class="fa fa-twitter" aria-hidden="true" style="color:#00aced"></i></a>or <a href="https://www.facebook.com/sharer/sharer.php?u=http://alvinsjq.github.io/2017/mit6828-lab2/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=235');return false;">facebook <i class="fa fa-facebook-square" aria-hidden="true" style="color:#3b5998"></i></a>.</p> </aside> </div> <style type="text/css"> .tagged { margin-top: 1rem; } .tagged a { border: 1px solid #ddd; padding: 2px 5px; background: transparent; display: inline-block; color: #999; outline: 0; text-decoration: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; font-size: 70%; } .tagged a:hover { cursor: pointer; border: 1px solid #555; background: #444; color: #fff; } .back { /*text-align: center;*/ text-transform: uppercase; letter-spacing: 1px; } </style> <div class="tagged"> <a href="http://alvinsjq.github.io/tagged#mit6-828"><i class="fa fa-hashtag" aria-hidden="true"></i>MIT6.828</a> <a href="http://alvinsjq.github.io/tagged#os"><i class="fa fa-hashtag" aria-hidden="true"></i>OS</a> <a href="http://alvinsjq.github.io/tagged#user-environments"><i class="fa fa-hashtag" aria-hidden="true"></i>User Environments</a> </div> <br> <div class="back"><a href="/"><i class="fa fa-chevron-left"></i>Back</a></div> </article> <aside id="comments" class="disqus"> <div class="container"> <div id="gitmentContainer"></div> <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"> <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script> <script> var gitment = new Gitment({ id: '<%= page.title %>', owner: 'Alvinsjq', repo: 'Alvinsjq.github.io', oauth: { client_id: 'b108345cd65235055f4a', client_secret: '2faaebf58d2e33a50a022d84c6448d9d9535feda', }, }); gitment.render('gitmentContainer'); </script> </div> </aside> <footer class="site-footer"> <div class="container"> <small class="block">&copy; 2018 Alvinsjq. All rights reserved.</small> <small><a href="https://github.com/heiswayi/thinkspace">Thanks for <i class="fa fa-heart" aria-hidden="true" style="color:#DD3D36"></i> Thinkspace</a> theme by <a href="http://heiswayi.github.io/">Heiswayi Nrird</a>.</small> <div class="footer-social-links"> <a href="http://alvinsjq.github.io/feed.xml" title="RSS Feed" target="_blank"><i class="fa fa-rss"></i></a> <a href="http://weibo.com/p/1005051719812480/home" title="Weibo" target="_blank"><i class="fa fa-weibo" aria-hidden="true"></i></a> <a href="https://twitter.com/Alvin_sjq" title="Twitter" target="_blank"><i class="fa fa-twitter"></i></a> <a href="https://github.com/Alvinsjq/" title="GitHub Repositories" target="_blank"><i class="fa fa-github-alt"></i></a> <a href="https://www.instagram.com/sj_alvin/" title="Instagram" target="_blank"><i class="fa fa-instagram"></i></a> </div> </div> </footer> </main> </body> </html>
